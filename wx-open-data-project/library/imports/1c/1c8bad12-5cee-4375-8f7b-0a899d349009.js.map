{"version":3,"sources":["..\\..\\..\\..\\assets\\Scripts/assets\\Scripts\\ScrollView.js"],"names":["cc","Class","extends","Component","properties","itemHeight","firstItem","Node","secondItem","thirdItem","commonItem","scrollView","default","type","ScrollView","spawnCount","totalCount","spacing","onLoad","initialize","content","items","updateTimer","updateInterval","lastContentPosY","bufferZone","height","i","item","instantiate","addChild","setPosition","getComponent","setItem","data","push","getPositionInView","worldPos","parent","convertToWorldSpaceAR","position","viewPos","node","convertToNodeSpaceAR","update","dt","length","isDown","y","offset","newY","itemId","itemID","log","setInitData","clear_scroll_data","scrollToOffset","v2","removeFromParent","destroy"],"mappings":"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","file":"ScrollView.js","sourceRoot":"..\\..\\..\\..\\assets\\Scripts","sourcesContent":["cc.Class({\r\n    extends: cc.Component,\r\n\r\n    properties: {\r\n\t\titemHeight:60,\r\n\t\tfirstItem:cc.Node,\r\n\t\tsecondItem:cc.Node,\r\n\t\tthirdItem:cc.Node,\r\n\t\tcommonItem:cc.Node,\r\n\t\tscrollView: {\r\n\t\t\tdefault: null,\r\n\t\t\ttype: cc.ScrollView\r\n\t\t},\r\n\t\tspawnCount: 0, // 实际创建的项数量\r\n\t\ttotalCount: 0, // 在列表中显示的项数量\r\n\t\tspacing: 0, // 项之间的间隔大小\r\n    },\r\n    onLoad () {\r\n\t\tthis.spacing = 10;\r\n\t},\r\n\t// 列表初始化\r\n    initialize: function () {\r\n\t\tthis.content = this.scrollView.content;\r\n\t\tthis.items = []; // 存储实际创建的项数组\r\n        this.updateTimer = 0;  \r\n        this.updateInterval = 0.2;\r\n\t\tthis.itemHeight = 100;\r\n        // 使用这个变量来判断滚动操作是向上还是向下\r\n        this.lastContentPosY = 0; \r\n        // 设定缓冲矩形的大小为实际创建项的高度累加，当某项超出缓冲矩形时，则更新该项的显示内容\r\n        this.bufferZone = this.spawnCount * (this.itemHeight + this.spacing) / 2;\r\n\t\t// 获取整个列表的高度\r\n        this.content.height = this.totalCount * (this.itemHeight + this.spacing) + this.spacing;\r\n    \tfor (let i = 0; i < this.spawnCount; ++i) { // spawn items, we only need to do this once\r\n\t\t\tvar item = null;\r\n\t\t\tif(i == 0){\r\n\t\t\t\titem = cc.instantiate(this.firstItem);\r\n\t\t\t}else if(i == 1){\r\n\t\t\t\titem = cc.instantiate(this.secondItem);\r\n\t\t\t}else if(i == 2){\r\n\t\t\t\titem = cc.instantiate(this.thirdItem);\r\n\t\t\t}else{\r\n\t\t\t\titem = cc.instantiate(this.commonItem);\r\n\t\t\t}\r\n    \t\t\r\n            this.content.addChild(item);\r\n            // 设置该item的坐标（注意父节点content的Anchor坐标是(0.5, 1)，所以item的y坐标总是负值）\r\n    \t\titem.setPosition(0, -item.height * (0.5 + i) - this.spacing * (i + 1));\r\n\t\t\titem.getComponent(\"RankItem\").setItem(i,this.data[i]);\r\n            this.items.push(item);\r\n    \t}\r\n    },\r\n\r\n    // 返回item在ScrollView空间的坐标值\r\n    getPositionInView: function (item) {\r\n        let worldPos = item.parent.convertToWorldSpaceAR(item.position);\r\n        let viewPos = this.scrollView.node.convertToNodeSpaceAR(worldPos);\r\n        return viewPos;\r\n    },\r\n\t // 每帧调用一次。根据滚动位置动态更新item的坐标和显示(所以spawnCount可以比totalCount少很多)\r\n    update: function(dt) {\r\n        this.updateTimer += dt;\r\n        if (this.updateTimer < this.updateInterval) {\r\n            return; // we don't need to do the math every frame\r\n        }\r\n\t\tif(this.items == null || this.items.length <= 0){\r\n\t\t\treturn;\r\n\t\t}\r\n        this.updateTimer = 0;\r\n        let items = this.items;\r\n        // 如果当前content的y坐标小于上次记录值，则代表往下滚动，否则往上。\r\n        let isDown = this.scrollView.content.y < this.lastContentPosY;\r\n        // 实际创建项占了多高（即它们的高度累加）\r\n        let offset = (this.itemHeight + this.spacing) * items.length;\r\n        let newY = 0;\r\n\r\n        // 遍历数组，更新item的位置和显示\r\n        for (let i = 0; i < items.length; ++i) {\r\n            let viewPos = this.getPositionInView(items[i]);\r\n            if (isDown) {\r\n                // 提前计算出该item的新的y坐标\r\n                newY = items[i].y + offset;\r\n                // 如果往下滚动时item已经超出缓冲矩形，且newY未超出content上边界，\r\n                // 则更新item的坐标（即上移了一个offset的位置），同时更新item的显示内容\r\n                if (viewPos.y < -this.bufferZone && newY < 0) {\r\n                    items[i].y = newY;\r\n\t\t\t\t\tlet item = items[i].getComponent('RankItem');\r\n                    let itemId = item.itemID - items.length; // update item id\r\n                    item.setItem(itemId,this.data[itemId]);\r\n\t\t\t\t\tcc.log(\"prev id:\" + itemId);\r\n                }\r\n            } else {\r\n                // 提前计算出该item的新的y坐标\r\n                newY = items[i].y - offset;\r\n                // 如果往上滚动时item已经超出缓冲矩形，且newY未超出content下边界，\r\n                // 则更新item的坐标（即下移了一个offset的位置），同时更新item的显示内容\r\n                if (viewPos.y > this.bufferZone && newY > -this.content.height) {\r\n                    items[i].y = newY;\r\n                    let item = items[i].getComponent('RankItem');\r\n                    let itemId = item.itemID + items.length;\r\n\t\t\t\t\titem.setItem(itemId,this.data[itemId]);\r\n\t\t\t\t\tcc.log(\"next id:\" + itemId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // 更新lastContentPosY和总项数显示\r\n        this.lastContentPosY = this.scrollView.content.y;\r\n    },\r\n\t//获取服务器上的残局数据\r\n\tsetInitData(data){\r\n\t\tthis.clear_scroll_data();\r\n\t\tthis.data = data;\r\n\t\tthis.totalCount = data.length;\r\n\t\tthis.spawnCount = this.totalCount >= 14 ? 14:this.totalCount;\r\n\t\tthis.initialize();\r\n\t},\r\n\tclear_scroll_data(){\r\n\t\tif(this.items == null){\r\n\t\t\treturn ;\r\n\t\t}\r\n\t\tthis.scrollView.scrollToOffset(cc.v2(0,0), 0.1);\r\n\t\tfor (let i = 0; i < this.items.length; i++) { // spawn items, we only need to do this once\r\n\t\t\tlet item = this.items[i];\r\n\t\t\titem.removeFromParent();\r\n\t\t\titem.destroy();\r\n    \t}\r\n\t},\r\n});"]}